use core::fmt;
use std::error::Error;
use strum_macros::EnumIter;
use tarantool::error::Error as TrtlErr;
use tarantool::index::SequenceOpt;
use tarantool::space::{FieldType, Space};
use tarantool::transaction::TransactionError;

pub mod todo;
pub mod user;

/// Tarantool Spaces used by application
#[derive(EnumIter, Debug, PartialEq)]
pub enum RepoSpaces {
    User,
    Todo,
}

impl RepoSpaces {
    pub fn create(&self) -> Result<(), RepoErr> {
        let space_name = self.name();
        match self {
            Self::User => {
                let user_space = Space::builder(space_name)
                    .format([("id", FieldType::Unsigned), ("name", FieldType::String)])
                    .if_not_exists(true)
                    .create()?;

                user_space
                    .index_builder("user_idx")
                    .part("id")
                    .sequence(SequenceOpt::AutoGenerated(true))
                    .if_not_exists(true)
                    .create()?;

                user_space
                    .index_builder("user_name")
                    .part("name")
                    .if_not_exists(true)
                    .create()?;

                Ok(())
            }
            Self::Todo => {
                let todo_space = Space::builder("todo")
                    .format([
                        ("id", FieldType::Unsigned),
                        ("title", FieldType::String),
                        ("completed", FieldType::Boolean),
                    ])
                    .if_not_exists(true)
                    .create()?;

                todo_space
                    .index_builder("todo_idx")
                    .part("id")
                    .sequence(SequenceOpt::AutoGenerated(true))
                    .if_not_exists(true)
                    .create()?;

                Ok(())
            }
        }
    }

    pub fn name(&self) -> &'static str {
        match self {
            Self::User => "user",
            Self::Todo => "todo",
        }
    }

    pub fn find(&self) -> Result<Space, RepoErr> {
        let space_name = self.name();
        Space::find_cached(space_name).ok_or(RepoErr::SpaceNotFinded(String::from(space_name)))
    }

    #[allow(dead_code)]
    pub fn empty(&self) -> Result<(), RepoErr> {
        let space_name = self.name();
        let space = Space::find_cached(space_name)
            .ok_or(RepoErr::SpaceNotFinded(String::from(space_name)))?;
        space.truncate()?;
        Ok(())
    }
}

/// error returned by repo methods
#[derive(Debug)]
pub enum RepoErr {
    SpaceNotFinded(String),
    FieldNotExsist(String),
    EmptyTodoTitle,
    EmptyUserName,
    TrtlErr(TrtlErr),
}

impl PartialEq for RepoErr {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (RepoErr::SpaceNotFinded(msg1), RepoErr::SpaceNotFinded(msg2)) => msg1 == msg2,
            (RepoErr::FieldNotExsist(msg1), RepoErr::FieldNotExsist(msg2)) => msg1 == msg2,
            (RepoErr::EmptyTodoTitle, RepoErr::EmptyTodoTitle) => true,
            (RepoErr::EmptyUserName, RepoErr::EmptyUserName) => true,
            (RepoErr::TrtlErr(_), RepoErr::TrtlErr(_)) => true,
            _ => false,
        }
    }
}

impl From<TransactionError<TrtlErr>> for RepoErr {
    fn from(err: TransactionError<TrtlErr>) -> RepoErr {
        RepoErr::TrtlErr(err.into())
    }
}

impl From<TrtlErr> for RepoErr {
    fn from(err: TrtlErr) -> RepoErr {
        RepoErr::TrtlErr(err)
    }
}

impl fmt::Display for RepoErr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            RepoErr::SpaceNotFinded(space) => write!(f, "space {space} not found"),
            RepoErr::FieldNotExsist(field) => write!(f, "field {field} not exist"),
            RepoErr::EmptyTodoTitle => write!(f, "empty todo title"),
            RepoErr::EmptyUserName => write!(f, "empty user name"),
            RepoErr::TrtlErr(..) => write!(f, "tarantool error"),
        }
    }
}

impl Error for RepoErr {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match *self {
            RepoErr::SpaceNotFinded(..) => None,
            RepoErr::FieldNotExsist(..) => None,
            RepoErr::EmptyTodoTitle => None,
            RepoErr::EmptyUserName => None,
            RepoErr::TrtlErr(ref e) => Some(e),
        }
    }
}
